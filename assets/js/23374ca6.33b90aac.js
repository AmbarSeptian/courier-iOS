"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[421],{3905:function(e,n,t){t.d(n,{Zo:function(){return u},kt:function(){return m}});var i=t(7294);function o(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function r(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);n&&(i=i.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,i)}return t}function a(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?r(Object(t),!0).forEach((function(n){o(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):r(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}function l(e,n){if(null==e)return{};var t,i,o=function(e,n){if(null==e)return{};var t,i,o={},r=Object.keys(e);for(i=0;i<r.length;i++)t=r[i],n.indexOf(t)>=0||(o[t]=e[t]);return o}(e,n);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(i=0;i<r.length;i++)t=r[i],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(o[t]=e[t])}return o}var s=i.createContext({}),c=function(e){var n=i.useContext(s),t=n;return e&&(t="function"==typeof e?e(n):a(a({},n),e)),t},u=function(e){var n=c(e.components);return i.createElement(s.Provider,{value:n},e.children)},p={inlineCode:"code",wrapper:function(e){var n=e.children;return i.createElement(i.Fragment,{},n)}},d=i.forwardRef((function(e,n){var t=e.components,o=e.mdxType,r=e.originalType,s=e.parentName,u=l(e,["components","mdxType","originalType","parentName"]),d=c(t),m=o,k=d["".concat(s,".").concat(m)]||d[m]||p[m]||r;return t?i.createElement(k,a(a({ref:n},u),{},{components:t})):i.createElement(k,a({ref:n},u))}));function m(e,n){var t=arguments,o=n&&n.mdxType;if("string"==typeof e||o){var r=t.length,a=new Array(r);a[0]=d;var l={};for(var s in n)hasOwnProperty.call(n,s)&&(l[s]=n[s]);l.originalType=e,l.mdxType="string"==typeof e?e:o,a[1]=l;for(var c=2;c<r;c++)a[c]=t[c];return i.createElement.apply(null,a)}return i.createElement.apply(null,t)}d.displayName="MDXCreateElement"},6527:function(e,n,t){t.r(n),t.d(n,{assets:function(){return u},contentTitle:function(){return s},default:function(){return m},frontMatter:function(){return l},metadata:function(){return c},toc:function(){return p}});var i=t(7462),o=t(3366),r=(t(7294),t(3905)),a=["components"],l={},s=void 0,c={unversionedId:"README",id:"README",title:"README",description:"Overview",source:"@site/docs/README.md",sourceDirName:".",slug:"/",permalink:"/courier-iOS/docs/",draft:!1,editUrl:"https://github.com/gojek/courier-iOS/blob/docusauras/docs/docs/README.md",tags:[],version:"current",frontMatter:{},sidebar:"tutorialSidebar",next:{title:"Courier iOS - Contribution Guidelines",permalink:"/courier-iOS/docs/CONTRIBUTION"}},u={},p=[{value:"Overview",id:"overview",level:2},{value:"Getting Started",id:"getting-started",level:2},{value:"Sample App",id:"sample-app",level:3},{value:"Installation",id:"installation",level:3},{value:"Implement IConnectionServiceProvider to provide ConnectOptions for Authentication",id:"implement-iconnectionserviceprovider-to-provide-connectoptions-for-authentication",level:3},{value:"Configure and Create MQTT CourierClient Instance with CourierClientFactory",id:"configure-and-create-mqtt-courierclient-instance-with-courierclientfactory",level:3},{value:"Managing Connection Lifecycle in CourierClient",id:"managing-connection-lifecycle-in-courierclient",level:3},{value:"QoS level in MQTT",id:"qos-level-in-mqtt",level:3},{value:"Subscribe to topics from Broker",id:"subscribe-to-topics-from-broker",level:3},{value:"Receive Message from Subscribed Topic",id:"receive-message-from-subscribed-topic",level:3},{value:"Unsubscribe from topics",id:"unsubscribe-from-topics",level:3},{value:"Send Message to Broker",id:"send-message-to-broker",level:3},{value:"Listen to Courier internal events",id:"listen-to-courier-internal-events",level:3},{value:"Contribution Guidelines",id:"contribution-guidelines",level:2},{value:"License",id:"license",level:2}],d={toc:p};function m(e){var n=e.components,t=(0,o.Z)(e,a);return(0,r.kt)("wrapper",(0,i.Z)({},d,t,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("h2",{id:"overview"},"Overview"),(0,r.kt)("p",null,"Courier is a library for creating long running connections using ",(0,r.kt)("a",{parentName:"p",href:"https://mqtt.org"},"MQTT")," which is the industry standard for IoT Messaging. Long running connection is a persistent connection established between client & server for bi-directional communication. A long running connection is maintained for as long as possible with the help of keepalive packets for instant updates. This also saves battery and data on mobile devices."),(0,r.kt)("h2",{id:"getting-started"},"Getting Started"),(0,r.kt)("p",null,"Setup Courier to subscribe, send, and receive message with bi-directional long running connection between iOS device and broker."),(0,r.kt)("h3",{id:"sample-app"},"Sample App"),(0,r.kt)("p",null,"You can run the sample App that connects to ",(0,r.kt)("a",{parentName:"p",href:"https://broker.mqttdashboard.com"},"HiveMQ")," public broker. Select ",(0,r.kt)("inlineCode",{parentName:"p"},"Chat-Example")," from the scheme."),(0,r.kt)("h3",{id:"installation"},"Installation"),(0,r.kt)("p",null,"Courier uses Cocoapods for adding it as a dependency to a project in a ",(0,r.kt)("inlineCode",{parentName:"p"},"Podfile"),". It is separated into 5 modules:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"CourierCore"),": Contains public APIs such as protocols and data types for Courier. Other modules have basic dependency on this module. You can use this module if you want to implement the interface in your project without adding Courier implementation in your project."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"CourierMQTT"),": Contains implementation of ",(0,r.kt)("inlineCode",{parentName:"li"},"CourierClient")," and ",(0,r.kt)("inlineCode",{parentName:"li"},"CourierSession")," using ",(0,r.kt)("inlineCode",{parentName:"li"},"MQTT"),". This module has dependency to ",(0,r.kt)("inlineCode",{parentName:"li"},"MQTTClientGJ"),"."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"MQTTClientGJ"),": A forked version of open source library ",(0,r.kt)("a",{parentName:"li",href:"https://github.com/novastone-media/MQTT-Client-Framework"},"MQTT-Client-Framework"),". It add several features such as connect and inactivity timeout. It also fixes race condition crashes in ",(0,r.kt)("inlineCode",{parentName:"li"},"MQTTSocketEncoder")," and ",(0,r.kt)("inlineCode",{parentName:"li"},"Connack")," status 5 not completing the decode before ",(0,r.kt)("inlineCode",{parentName:"li"},"MQTTTransportDidClose")," got invoked bugs."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"CourierProtobuf"),": Contains implementation of ",(0,r.kt)("inlineCode",{parentName:"li"},"ProtobufMessageAdapter")," using ",(0,r.kt)("inlineCode",{parentName:"li"},"Protofobuf"),". It has dependency to ",(0,r.kt)("inlineCode",{parentName:"li"},"SwiftProtobuf")," library, this is ",(0,r.kt)("inlineCode",{parentName:"li"},"optional")," and can be used if you are using protobuf for data serialization.")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ruby"},"// Podfile\ntarget 'Example-App' do\n  use_frameworks!\n  pod 'CourierCore'\n  pod 'CourierMQTT'\n  pod 'CourierProtobuf'\nend\n")),(0,r.kt)("h3",{id:"implement-iconnectionserviceprovider-to-provide-connectoptions-for-authentication"},"Implement IConnectionServiceProvider to provide ConnectOptions for Authentication"),(0,r.kt)("p",null,"To connect to MQTT broker you need to implement IConnectionServiceProvider. First you need to implement ",(0,r.kt)("inlineCode",{parentName:"p"},"IConnectionServiceProvider/clientId")," to return an unique string to identify your client. This must be unique for each device that connect to broker."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-swift"},"var clientId: String {\n    UIDevice.current.identifierForVendor?.uuidString ?? UUID().uuidString\n}\n")),(0,r.kt)("p",null,"Next, you need to implement ",(0,r.kt)("inlineCode",{parentName:"p"},"IConnectionServiceProvider/getConnectOptions(completion:)")," method. You need to provide ",(0,r.kt)("inlineCode",{parentName:"p"},"ConnectOptions")," instance that will be used to make connection to the broker. This method provides an escaping closure, in case you need to retrieve the credential from remote API asynchronously. "),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-swift"},"func getConnectOptions(completion: @escaping (Result<ConnectOptions, AuthError>) -> Void) {\n    executeNetworkRequest { (response: ConnectOptions) in\n        completion(.success(connectOptions))\n    } failure: { _, _, error in\n        completion(.failure(error))\n    }\n}\n")),(0,r.kt)("p",null,"Here are the data that you need to provide in ConnectOptions."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-swift"},"/// IP Host address of the broker\npublic let host: String\n/// Port of the broker\npublic let port: UInt16\n/// Keep Alive interval used to ping the broker over time to maintain the long run connection\npublic let keepAlive: UInt16\n/// Unique Client ID used by broker to identify connected clients\npublic let clientId: String\n/// Username of the client\npublic let username: String\n/// Password of the client used for authentication by the broker\npublic let password: String\n/// Tells broker whether to clear the previous session by the clients\npublic let isCleanSession: Bool\n")),(0,r.kt)("h3",{id:"configure-and-create-mqtt-courierclient-instance-with-courierclientfactory"},"Configure and Create MQTT CourierClient Instance with CourierClientFactory"),(0,r.kt)("p",null,"Next, we need to create instance of CourierClient that uses MQTT as its implementation. Initialize ",(0,r.kt)("inlineCode",{parentName:"p"},"CourierClientFactory")," instance and invoke ",(0,r.kt)("inlineCode",{parentName:"p"},"CourierClientFactory/makeMQTTClient(config:)"),". We need to pass instance MQTTClientConfig with several parameters that we can customize. "),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-swift"},"let clientFactory = CourierClientFactory()\nlet courierClient = clientFactory.makeMQTTClient(\n    config: MQTTClientConfig(\n        authService: HiveMQAuthService(),\n        messageAdapters: [\n            JSONMessageAdapter(),\n            ProtobufMessageAdapter()\n        ],\n        autoReconnectInterval: 1,\n        maxAutoReconnectInterval: 30\n    )\n)\n")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"MQTTClientConfig/messageAdapters"),": we need to pass array of ",(0,r.kt)("inlineCode",{parentName:"li"},"MessageAdapter"),". This will be used for serialization when receiving from broker and sending message to the broker. ",(0,r.kt)("inlineCode",{parentName:"li"},"CourierMQTT")," provides built in message adapters for JSON ",(0,r.kt)("inlineCode",{parentName:"li"},"(JSONMessageAdapter)")," and Plist ",(0,r.kt)("inlineCode",{parentName:"li"},"(PlistMessageAdapter)")," format that conforms to ",(0,r.kt)("inlineCode",{parentName:"li"},"Codable")," protocol. You can only use one of them because both implements to Codable to avoid any conflict. To use protobuf, please import ",(0,r.kt)("inlineCode",{parentName:"li"},"CourierProtobuf")," and pass ",(0,r.kt)("inlineCode",{parentName:"li"},"ProtobufMessageAdapter"),"."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"MQTTClientConfig/authService"),": we need to pass our implementation of IConnectionServiceProvider protocol for providing the ConnectOptions to the client."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"MQTTClientConfig/autoReconnectInterval")," The interval used to make reconnection to broker in case of connection lost. This will be multiplied by 2 for each time until it successfully make the connection. The upper limit is based on ",(0,r.kt)("inlineCode",{parentName:"li"},"MQTTClientConfig/maxAutoReconnectInterval"),".")),(0,r.kt)("h3",{id:"managing-connection-lifecycle-in-courierclient"},"Managing Connection Lifecycle in CourierClient"),(0,r.kt)("p",null,"To connect to the broker, you simply need to invoke ",(0,r.kt)("inlineCode",{parentName:"p"},"connect")," method"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-swift"},"courierClient.connect()\n")),(0,r.kt)("p",null,"To disconnect, you just need to invoke ",(0,r.kt)("inlineCode",{parentName:"p"},"disconnect")," method"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-swift"},"courierClient.disconnect()\n")),(0,r.kt)("p",null,"To get the ConnectionState, you can access the CourierSession/connectionState property"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-swift"},"courierClient.connectionState\n")),(0,r.kt)("p",null,"You can also subscribe the ",(0,r.kt)("inlineCode",{parentName:"p"},"ConnectionState")," publisher using the ",(0,r.kt)("inlineCode",{parentName:"p"},"CourierSession/connectionStatePublisher")," property. The observable API that Courier provide is very similar to ",(0,r.kt)("inlineCode",{parentName:"p"},"Apple Combine")," although it is implemented internally using ",(0,r.kt)("inlineCode",{parentName:"p"},"RxSwift")," so we can support ",(0,r.kt)("inlineCode",{parentName:"p"},"iOS 12"),"."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-swift"},"courierClient.connectionStatePublisher\n    .sink { [weak self] self?.handleConnectionStateEvent($0) }\n    .store(in: &cancellables)\n")),(0,r.kt)("p",null,"As MQTT supports QoS 1 and QoS 2 message to ensure deliverability when there is no internet connection and user reconnected back to broker, we also persists those message in local cache. To disconnect and remove all of this cache, you can invoke."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-swift"},"courierClient.destroy()\n")),(0,r.kt)("p",null,"There are several things that you need to keep in mind when using Courier:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"Courier will always disconnect when the app goes to background as iOS doesn't support long run socket connection in background."),(0,r.kt)("li",{parentName:"ul"},"Courier will always automatically reconnect when the app goes to foreground if there is a topic to subscribe."),(0,r.kt)("li",{parentName:"ul"},"Courier handles reconnection in case of bad/lost internet connection using Reachability framework."),(0,r.kt)("li",{parentName:"ul"},"Courier will persist QoS > 0 messages in case there are no active subscription to Observable/Publisher using configurable TTL.")),(0,r.kt)("h3",{id:"qos-level-in-mqtt"},"QoS level in MQTT"),(0,r.kt)("p",null,"The Quality of Service (QoS) level is an agreement between the sender of a message and the receiver of a message that defines the guarantee of delivery for a specific message. There are 3 QoS levels in MQTT:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"At most once (0)"),(0,r.kt)("li",{parentName:"ul"},"At least once (1)"),(0,r.kt)("li",{parentName:"ul"},"Exactly once (2).")),(0,r.kt)("p",null,"When you talk about QoS in MQTT, you need to consider the two sides of message delivery:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"Message delivery form the publishing client to the broker."),(0,r.kt)("li",{parentName:"ul"},"Message delivery from the broker to the subscribing client.")),(0,r.kt)("p",null,"You can read more about the detail of QoS in MQTT from ",(0,r.kt)("a",{parentName:"p",href:"https://www.hivemq.com/blog/mqtt-essentials-part-6-mqtt-quality-of-service-levels/"},"HiveMQ")," site."),(0,r.kt)("h3",{id:"subscribe-to-topics-from-broker"},"Subscribe to topics from Broker"),(0,r.kt)("p",null,"To subscribe to a topic from the broker. we can invoke ",(0,r.kt)("inlineCode",{parentName:"p"},"CourierSession/subscribe(_:)")," and pass a tuple containing the topic string and QoS enum."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-swift"},'courierClient.subscribe(("chat/user1", QoS.zero))\n')),(0,r.kt)("p",null,"You can also subscribe to multiple topics, invoking ",(0,r.kt)("inlineCode",{parentName:"p"},"CourierSession/subscribe(_:)")," and pass an array containing tuples of topic string and QoS enum"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-swift"},'courierClient.subscribe([\n    ("chat/user1", QoS.zero),\n    ("order/1234", QoS.one),\n    ("order/123456", QoS.two),\n])\n')),(0,r.kt)("h3",{id:"receive-message-from-subscribed-topic"},"Receive Message from Subscribed Topic"),(0,r.kt)("p",null,"After you have subscribed to the topic, you need to subscribe to a message publisher passing the associated topic using ",(0,r.kt)("inlineCode",{parentName:"p"},"CourierSession/messagePublisher(topic:)"),". This method uses ",(0,r.kt)("inlineCode",{parentName:"p"},"Generic")," for serializing the binary data to a type. Make sure you have provided the associated MessageAdapter that can decode the data to the type. "),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-swift"},'courierClient.messagePublisher(topic: topic)\n    .sink { [weak self] (note: Note) in\n        self?.messages.insert(Message(id: UUID().uuidString, name: "Protobuf: \\(note.title)", timestamp: Date()), at: 0)\n    }.store(in: &cancellables)\n')),(0,r.kt)("p",null,"This method returns AnyPublisher which you can chain with operators such as ",(0,r.kt)("inlineCode",{parentName:"p"},"AnyPublisher/filter(predicate:)")," or ",(0,r.kt)("inlineCode",{parentName:"p"},"AnyPublisher/map(transform:)"),"."),(0,r.kt)("p",null,"The observable API that Courier provide is very similar to Apple Combine although it is implemented internally using RxSwift so we can support iOS 12, only the ",(0,r.kt)("inlineCode",{parentName:"p"},"filter")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"map")," operators are supported."),(0,r.kt)("h3",{id:"unsubscribe-from-topics"},"Unsubscribe from topics"),(0,r.kt)("p",null,"To unsubscribe from a topic. we can invoke ",(0,r.kt)("inlineCode",{parentName:"p"},"CourierSession/unsubscribe(_:)")," and pass a topic string."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-swift"},'courierClient.unsubscribe("chat/user1")\n')),(0,r.kt)("p",null,"You can also subscribe to multiple topics, invoking ",(0,r.kt)("inlineCode",{parentName:"p"},"CourierSession/unsubscribe(_:)")," and pass an array containing tuples of topic string and QoS enum"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-swift"},'courierClient.unsubscribe([\n    "chat/user1",\n    "order/"\n])\n')),(0,r.kt)("h3",{id:"send-message-to-broker"},"Send Message to Broker"),(0,r.kt)("p",null,"To send the message to the broker, first make sure you have provided a ",(0,r.kt)("inlineCode",{parentName:"p"},"MessageAdapter")," that is able to encode your object to the binary data format. For example, if you have a data struct that you want to send as JSON. Make sure, it conforms to ",(0,r.kt)("inlineCode",{parentName:"p"},"Encodable")," protocol and pass ",(0,r.kt)("inlineCode",{parentName:"p"},"JSONMessageAdapter")," in ",(0,r.kt)("inlineCode",{parentName:"p"},"MQTTClientConfig")," when creating the ",(0,r.kt)("inlineCode",{parentName:"p"},"CourierClient")," instance."),(0,r.kt)("p",null,"You simply need to invoke ",(0,r.kt)("inlineCode",{parentName:"p"},"CourierSession/publishMessage(_:topic:qos:)")," passing the topic string and QoS enum. This is a ",(0,r.kt)("inlineCode",{parentName:"p"},"throwing")," function which can throw in case it fails to encode to data."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-swift"},'let message = Message(\n    id: UUID().uuidString,\n    name: message,\n    timestamp: Date()\n)\n        \ntry? courierService?.publishMessage(\n    message,\n    topic: "chat/1234",\n    qos: QoS.zero\n)\n')),(0,r.kt)("h3",{id:"listen-to-courier-internal-events"},"Listen to Courier internal events"),(0,r.kt)("p",null,"To listen to Courier system events such on ",(0,r.kt)("inlineCode",{parentName:"p"},"CourierEvent/connectionSuccess"),", ",(0,r.kt)("inlineCode",{parentName:"p"},"CourierEvent/connectionAttempt"),", and many more casess declared in ",(0,r.kt)("inlineCode",{parentName:"p"},"CourierEvent")," enum, you can implement the ",(0,r.kt)("inlineCode",{parentName:"p"},"ICourierEventHandler")," protocol and implement ",(0,r.kt)("inlineCode",{parentName:"p"},"ICourierEventHandler/onEvent(_:)")," method. This method will be invoked for any courier system events."),(0,r.kt)("p",null,"Finally, make sure to have strong reference to the instance, and invoke ",(0,r.kt)("inlineCode",{parentName:"p"},"CourierEventManager/addEventHandler(_:)")," passing the instance."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-swift"},"courierClient.addEventHandler(analytics)\n")),(0,r.kt)("h2",{id:"contribution-guidelines"},"Contribution Guidelines"),(0,r.kt)("p",null,"Read our ",(0,r.kt)("a",{parentName:"p",href:"/courier-iOS/docs/CONTRIBUTION"},"contribution guide")," to learn about our development process, how to propose bugfixes and improvements, and how to build and test your changes to Courier iOS library."),(0,r.kt)("h2",{id:"license"},"License"),(0,r.kt)("p",null,"All Courier modules except MQTTClientGJ are ",(0,r.kt)("a",{parentName:"p",href:"LICENSE"},"MIT Licensed"),". MQTTClientGJ is ",(0,r.kt)("a",{parentName:"p",href:"LICENSE.MQTTClientGJ"},"Eclipse Licensed"),"."))}m.isMDXComponent=!0}}]);